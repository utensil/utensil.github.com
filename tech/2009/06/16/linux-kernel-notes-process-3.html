<!DOCTYPE html> <html> <head> <meta charset=utf-8> <meta content='IE=edge,chrome=1' http-equiv=X-UA-Compatible> <!--[if (lt IE 9)&(!IEMobile)]><script src="/javascripts/html5.js?1562487795"></script><![endif]--> <meta content='width=device-width, initial-scale=1.0' name=viewport> <title>Linux 2.6内核笔记【Process-3：fork、内核进程】</title> <link href="/stylesheets/site.css?1562487795" rel=stylesheet /> <link href="/stylesheets/blog.css?1562487795" rel=stylesheet /> <link href="/stylesheets/highlight/railscasts.css?1562487795" rel=stylesheet /> <!--[if lt IE 9]><script src="/javascripts/respond.js?1562487795"></script><![endif]--> </head> <body class=''> <div id=container> <div id=main role=main> <aside class=sidebar> <nav> <span> <a href='/tech/'>home</a> </span> <span> <a href='/tech/calendar.html'>calendar</a> </span> <span> <a href='/tech/tags.html'>tags</a> </span> </nav> </aside> <div class=content> <header> <div class=article_nav> <span class=later> <a href='/tech/2009/06/19/linux-kernel-notes-kernel-preemption-etc.html'> < 更新 </a> </span> <span class=earlier> <a href='/tech/2009/05/09/linux-kernel-notes-process-2.html'> 更早 > </a> </span> </div> <h1> Linux 2.6内核笔记【Process-3：fork、内核进程】 </h1> </header> <article class=markdown-body> <blockquote> <p>按：最后的几篇Linux内核笔记实在是太难产了，这中途读完了APUE，并以JavaEye闲聊的形式做了无数细小的笔记（不日将整理为博客）；也第3次（还是第4次?）阅读了《ACE程序员指南》，不过这一次终于做下了笔记；也看完了Programming Erlang，用Erlang来写基于UDP的TCP的ErlyUbt已经渐渐现出眉目，也已push到了GitHub上面。可惜就是这段时间的该做的正事却没什么进展...</p> <p>《Understanding Linux Kernel》在18号必须还给图书馆了...在这两天电脑坏了的日子里，第3次读了即将做笔记的中断与异常、内核同步、时间测量，其余的章节也略读完毕，这些章节希望能够写成一些细小的闲聊。预期电脑应该在今晚恢复正常，在这之前，我来到图书馆，开始写作这酝酿已久的笔记。 第一篇，是对Process的一个收尾。</p> </blockquote> <h2>Process的终止 </h2> <p>这不是本笔记关注的重点，只记下以下一点：</p> <p>C库函数<code>exit()</code>调用<code>exit_group()</code>系统调用（做事的是<code>do_group_exit()</code>），这会终止整个线程组，而<code>exit_group()</code>会调用<code>exit()</code>系统调用（做事的是<code>do_exit()</code>）来终止一个指定的线程。 </p> <h2>Process的诞生</h2> <p>POSIX里，创建process需要<code>fork()</code>，古老的<code>fork()</code>是很汗的，它会完整复制父进程的所有资源。Linux则将fork细分为下面三种情况：</p> <p>如果是fork一个正常进程，那么就用Copy-on-Write（CoW）技术，子进程先用着父进程的所有页，它企图修改某一页时，再复制那一页给它去改；</p> <p>如果要的是线程（轻量级进程），那么就是大家共同享有原先那些资源，大家一条船；</p> <p>还有就是<code>vfork()</code>所代表的情况：子进程创建出来后，父进程阻塞，这样老虎不在家，猴子当大王，子进程继续用原先的地址空间，直到它终止，或者执行新的程序，父进程就结束阻塞。</p> <p>一个关于系统调用的准备知识：系统调用<code>xyz()</code>的函数名往往为<code>sys_xyz()</code>，下文对系统调用仅以<code>sys_xyz()</code>的形态表达。</p> <h2>clone()界面</h2> <p>在Linux里，创建进程的总的界面是<code>clone()</code>，这个函数并没有定义在Linux内核源代码中，而是libc的一部分，它负责建立新进程的stack并调用<code>sys_clone()</code>。而<code>sys_clone()</code>里面实际干活的是<code>do_fork()</code>，而<code>do_fork()</code>做了许多前前后后的琐事，真正复制进程描述符和相关数据结构的是<code>copy_process()</code>。</p> <p><code>clone()</code>是这个样子的：clone(fn, arg, flags, child_stack, 其它我们不关心的参数)。</p> <p>fn是新进程应执行的函数， arg是这个函数的参数。</p> <p>flags的低字节指定新进程结束时发送给老进程的信号，通常为SIGCHLD，高字节则为clone_flag，clone_flag很重要，它决定了clone的行为。有趣的一些clone_flag包括（这些flag定义于<linux/include/linux/sched.h>）：</p> <ul> <li>CLONE_VM(Virtual Memory)：新老进程共享memory descriptor和所有Page Table；</li> <li>CLONE_FS(File System)；</li> <li>CLONE_FILES；</li> <li>CLONE_SIGHAND(Signal Handling)：新老进程共享信号描述符（signal * handler和现已blocked/pending的信号队列）；</li> <li>CLONE_PTRACE：用于Debugging；</li> <li>CLONE_PARENT：老进程的real_parent登记为新进程的parent和real_parent；</li> <li>CLONE_THREAD：新进程加入老进程的线程组；</li> <li>CLONE_STOPPED：创建你，但你别运行。</li> </ul> <p>child_stack则是新进程用户态stack的地址，要么共享老进程的，要么老进程应为新进程分配新的stack。</p> <h2>do_fork()探究</h2> <p>书中说：<code>fork()</code>和<code>vfork()</code>只不过是建立在调用<code>clone()</code>基础上的wrapper函数（也在libc中），实际上：</p> <pre><code class="cpp">asmlinkage int sys_fork(struct pt_regs regs)  
{  
        return do_fork(SIGCHLD, regs.esp, &amp;regs, 0, NULL, NULL);  
}  

asmlinkage int sys_clone(struct pt_regs regs)  
{  
        /* 略去用于把regs拆开成可以传递给do_fork的参数的代码 */  
        return do_fork(clone_flags, newsp, &amp;regs, 0, parent_tidptr, child_tidptr);  
}  

asmlinkage int sys_vfork(struct pt_regs regs)  
{  
        return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.esp, &amp;regs, 0, NULL, NULL);  
}
</code></pre> <p>我一开始猜想，<code>fork()</code>和<code>vfork()</code>直接呼唤<code>sys_fork()</code>和<code>sys_vfork()</code>应该也没什么问题，但是，注意到这三个系统调用都只接受pt_regs这样仅包含寄存器的参数，显然<code>clone()</code>的工作中主要的部分是把它自身接受的参数转换成寄存器的值，事实上，clone还需要将fn和args压入stack，因为<code>do_fork()</code>是这样子的：</p> <p><code>do_fork(clone_flags, stack_start, regs, 一些我们不关心的参数)</code></p> <p>也就是说<code>do_fork()</code>不了解也不需要知道fn和args，它做完fork之后，在某个return处，类似于之前在process切换用过的技巧（jmp+ret）将使CPU从stack中获取返回地址，并错误而正确地拿到了fn的地址。这正是<code>clone()</code>这个wrapper要做的事情，<code>fork()</code>和<code>vfork()</code>不妨复用<code>clone()</code>的辛苦。</p> <p><code>do_fork()</code>调用完copy_process之后，除非你指定CLONE_STOPPED，就会呼唤<code>wake_up_new_task()</code>，这里面有一点很有趣：</p> <p>如果新老进程在同一CPU上运行，而且没有指定CLONE_VM（也就是终究要分家，要动用CoW），那么就会让新进程先于老进程运行，这样，如果新进程一上来就exec，就省去了CoW的功夫。</p> <p>这是因为exec内部会调用<code>flush_old_exec()</code>，从与老进程的共享中中脱离，从此拥有自己的信号描述符、文件，释放了原先的mmap，消灭了对老进程的所有知识——这正是为什么成功执行的exec不会返回也无法返回。总之，此后再也没有共享，自然也不会需要CoW。（参见《Program Execution》一章《exec function》中的介绍。）</p> <h2>内核进程（Kernel thread）</h2> <p>什么是书中所说的“内核线程”？首先要说明，由于Linux内核中对process和thread的混用，这里的thread其实完全可以理解为process，等价于普通的进程，不能理解为老进程中的一个属于内核的线程。因此，下文都称之为内核进程。</p> <p>内核进程是会和其他进城一样被调度的实体，它和进程的唯一区别就是，它永远运行于内核态，也只访问属于内核的那一部分线性地址（大于PAGE_OFFSET的）。</p> <p>这就使得创建它的时候非常省事，直接和创建它的普通进程共享小于PAGE_OFFSE的线性地址，反正它也不用：</p> <pre><code class="cpp">int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)  
{  
        /* 略去用于设置regs的代码 */  
        return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &amp;regs, 0, NULL, NULL);  
}
</code></pre> <p><linux/include/linux/sched.h>中甚至定义了</p> <pre><code class="cpp">#define CLONE_KERNEL     (CLONE_FS | CLONE_FILES | CLONE_SIGHAND )
</code></pre> <p>可供<code>kernel_thread()</code>调用的时候使用，这样节省的克隆就更多了。</p> <p>内核进程由于不受不必要的用户态上下文拖累，可以用于执行一些重要的内核任务，比如，刷新磁盘高速缓存，交换出不用的pageframe，服务网络连接等等，这些任务以前是周期性执行的进程，是线性的执行方式，现在的内核把用户态从他们身上剥离，并且和其它进程放到一起来调度，能获得更好的响应表现。</p> <p>所有进程的祖先是进程0，称为idle进程或swapper进程，它是内核初始化时创建的一个内核进程，它初始化一堆数据结构之后会创建init进程，执行<code>init()</code>函数，其中调用exec执行了init程序，至此，init进程变成了一个普通进程。而idle进程之后则一直执行<code>cpu_idle()</code>函数没事干。调度程序只有在没有进程处于可运行状态（TASK_RUNNING）才会选择它。</p> <p>如果有多个CPU，BIOS一开始会禁用其它CPU，只留一个，进程0就在其上诞生，它会激活其它CPU，并通过<code>copy_process()</code>让每个CPU都有一个pid为0的进程，从而形成了每个CPU都有一个0进程的局面。</p> <section class=meta> <p> <span class=author> <a href='/'>宋皿</a> </span> <span class=time> <time datetime='2009-06-16 00:00:00 +0800'> 2009-06-16 </time> </span> </p> <p> <span class=license> Published under <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/' rel=license>(CC) BY-NC-ND</a> </span> <span class=tags> tagged with <a href='/tech/tags.html#tag-内核'> 内核 </a> <a href='/tech/tags.html#tag-linux'> linux </a> <a href='/tech/tags.html#tag-读书笔记'> 读书笔记 </a> </span> </p> </section> <div id=disqus_thread></div> <script>
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'utensil-at-github'; // required: replace example with your forum shortname
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script> <a class=dsq-brlink href='http://disqus.com'> comments powered by <span class=logo-disqus>Disqus</span> </a> </article> </div> </div> </div> <script src="/javascripts/jquery-1.7.1.js?1562487795"></script> <script src="/javascripts/highlight.pack.js?1562487795"></script> <script>
  hljs.initHighlightingOnLoad();
  // $(document).ready(function() {
  //   $('pre code').each(function(i, e) {hljs.highlightBlock(e)});
  // });
</script> <script>
  // (function(e,b){if(!b.__SV){var a,f,i,g;window.mixpanel=b;a=e.createElement("script");a.type="text/javascript";a.async=!0;a.src=("https:"===e.location.protocol?"https:":"http:")+'//cdn.mxpnl.com/libs/mixpanel-2.2.min.js';f=e.getElementsByTagName("script")[0];f.parentNode.insertBefore(a,f);b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!== typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");for(g=0;g<i.length;g++)f(c,i[g]); b._i.push([a,e,d])};b.__SV=1.2}})(document,window.mixpanel||[]); mixpanel.init("eda89891866a7e90b6699df21e79ea61");
  // mixpanel.track("visit");
</script> </body> </html>