<!DOCTYPE html> <html> <head> <meta charset=utf-8> <meta content='IE=edge,chrome=1' http-equiv=X-UA-Compatible> <!--[if (lt IE 9)&(!IEMobile)]><script src="/javascripts/html5.js?1620110719"></script><![endif]--> <meta content='width=device-width, initial-scale=1.0' name=viewport> <title>Linux 2.6内核笔记【中断、异常、抢占内核】</title> <link href="/stylesheets/site.css?1620110719" rel=stylesheet /> <link href="/stylesheets/blog.css?1620110719" rel=stylesheet /> <link href="/stylesheets/highlight/railscasts.css?1620110719" rel=stylesheet /> <!--[if lt IE 9]><script src="/javascripts/respond.js?1620110719"></script><![endif]--> </head> <body class=''> <div id=container> <div id=main role=main> <aside class=sidebar> <nav> <span> <a href='/tech/'>home</a> </span> <span> <a href='/tech/calendar.html'>calendar</a> </span> <span> <a href='/tech/tags.html'>tags</a> </span> </nav> </aside> <div class=content> <header> <div class=article_nav> <span class=later> <a href='/tech/2009/06/19/linux-kernel-notes-kernel-sync.html'> < 更新 </a> </span> <span class=earlier> <a href='/tech/2009/06/16/linux-kernel-notes-process-3.html'> 更早 > </a> </span> </div> <h1> Linux 2.6内核笔记【中断、异常、抢占内核】 </h1> </header> <article class=markdown-body> <blockquote> <p>2009.6.18更新：参考<a href="http://linux.derkeiler.com/Mailing-Lists/Kernel/2004-03/4562.html">http://linux.derkeiler.com/Mailing-Lists/Kernel/2004-03/4562.html</a> ，查证LXR，重新诠释PREEMPT_ACTIVE标志。</p> </blockquote> <h2>中断信号分类</h2> <p>中断信号是一个统称，统称那些改变CPU指令执行序列的事件。但它又分为两种：</p> <ul> <li> <p>一种是同步的，没那么突然，因为它只在一个指令的执行终止之后才发生，书中依从Intel的惯例，称为异常（Exception）。一般是编程错误（一般的处理是发信号）或者内核必须处理的异常情况（内核会采取恢复异常所需的一些步骤）；</p> </li> <li> <p>一种是异步的，突然一些，因为它是由间隔定时器和I/O设备产生的，只遵循CPU时钟信号，所以可能在任何时候产生，书中也依从Intel的惯例，称为中断（Interrupt）。</p> </li> </ul> <h2>内核控制路径</h2> <p>内核在允许中断信号到来之前，必须先准备好对它们的处理，也就是适当地初始化中断描述符表（Interrupt Descriptor Table, IDT）。</p> <p>中断信号一来，CPU控制单元就自动把当前的程序计数器（eip、cs）和eflags保存到内核stack，然后把事先与发生的中断信号类型关联好的处理程序的地址（保存在IDT中）放进程序计数器。这时，内核控制路径（kernel control path）横空出世。</p> <p>什么是内核控制路径？它是不是一个进程？不是。内核进程？也不是。它虽然也需要切换上下文，需要保存那些它可能使用的寄存器的并在返回时恢复，但这是一个非常轻的上下文切换。它诞生的时候并没有发生进程切换，处理中断的主语仍然是中断发生时正在执行的那个进程。那个进程就像突然被内核抓进了一间小屋做事，或者突然潜入了水（内核）里不见踪影，但它仍然在使用分配给它的那段时间片。</p> <p>有趣的是，如果一个进程还在处理一个异常的时候，分配给它的时间片到期了，会发生什么事情呢？这取决于有没有启用内核抢占（Kernel Preemption），如果没有启用，进程就继续处理异常，如果启用了，进程可能会立即被抢占，异常的处理也就暂停了，直到<code>schedule()</code>再度选择原先那个进程（注意：内核处理中断的时候，必然会禁用内核抢占，所以这里才说是异常）。</p> <h2>中断信号处理的约束</h2> <p>中断信号处理需要满足下面三个严格的约束：</p> <ol> <li> <p>中断处理要尽可能块地完成、返回。因此只执行关键而紧急的部分，尽可能把更多的后续处理过程仅仅标志一下，放到之后再去执行。</p> </li> <li> <p>一个中断还在处理的时候，另外一个中断可能又来了，这个时候最好能先放下手中的处理，先去处理新的中断，然后在回头来接着处理这个中断，这称之为中断和异常处理程序的嵌套执行（nested execution），或者说是内核控制路径的嵌套执行。要实现这一点，有一点必须满足，那就是中断处理程序运行期间不能阻塞，不能发生进程切换。</p> </li> </ol> <p>如果对异常的种类做一番思考，就会发现，异常最多嵌套两层，一个由系统调用产生，一个由系统调用执行过程中的缺页产生（这时必然挂起当前进程，发生进程切换）。与之相反，在复杂的情况下，中断产生的嵌套则可能任意多。</p> <ol start=3> <li>内核中存在一些临界区，在这些临界区，中断必须被禁止。中断处理程序要尽可能地减少进入临界区的次数和时间，为了内核的响应性能，中断应该在大部分时间都是启用的。</li> </ol> <h2>异常的种类</h2> <p>异常有很多种，其中比较有趣的有：</p> <table> <thead> <tr> <th>编号</th> <th>异常</th> <th>异常处理程序</th> <th>信号</th> <th>有趣之处</th> </tr> </thead> <tbody> <tr> <td>1</td> <td>Debug</td> <td>debug()</td> <td>SIGTRAP</td> <td>用于调试</td> </tr> <tr> <td>3</td> <td>Breakpoint</td> <td>int3()</td> <td>SIGTRAP</td> <td></td> </tr> <tr> <td>7</td> <td>Device not available</td> <td>device_not_available()</td> <td>None</td> <td>用于在需要的时候才加载FPU 、MMX 、XMM(当cr0的TS标志被设置)</td> </tr> <tr> <td>14</td> <td>Page Fault</td> <td>page_fault()</td> <td>SIGSEGV</td> <td>如果是正常缺页，内核会挂起</td> </tr> <tr> <td>4</td> <td>Overflow</td> <td>overflow()</td> <td>SIGSEGV</td> <td>调试时非常常见的一个信号SIGSEQV ，Segment Violation ，呵呵，关注一下都是什么异常导致的。</td> </tr> <tr> <td>5</td> <td>Bounds check</td> <td>bounds()</td> <td>SIGSEGV</td> <td></td> </tr> <tr> <td>10</td> <td>Invalid TSS</td> <td>invalid_TSS()</td> <td>SIGSEGV</td> <td></td> </tr> <tr> <td>13</td> <td>General protection</td> <td>general_protection()</td> <td>SIGSEGV</td> <td></td> </tr> </tbody> </table> <h2>中断描述符</h2> <p>Intel 80x86 CPU认得三种中断描述符，Linux为了检验权限，将其细分为：</p> <ul> <li>Interrupt Gate， DPL = 0的中断门，<code>set_intr_gate(n,addr)</code>，所有中断</li> <li>System Interrupt Gate，DPL = 3的中断门，<code>set_system_intr_gate(n,addr)</code>，int3异常</li> <li>System Gate，DPL = 3的陷阱门，<code>set_system_gate(n,addr)</code>，into、bound、int $0x80异常</li> <li>Trap Gate， DPL = 0的陷阱门，<code>set_trap_gate(n,addr)</code>，大部分异常</li> <li>Task Gate， DPL = 0的任务门，<code>set_task_gate(n,gdt)</code>，double fault异常</li> </ul> <h2>异常处理的标准结构</h2> <ol> <li>用汇编把大多数寄存器的值保存到kernel stack；</li> <li>用C函数处理异常</li> <li>通过ret_from_exception( ) 函数退出处理程序.</li> </ol> <h2>I/O中断处理的标准结构</h2> <ol> <li>将IRQ值和寄存器值保存到kernel stack；</li> <li>给服务这条IRQ线的PIC发送应答，从而允许它继续发出中断；</li> <li>执行和所有共享此IRQ的设备相关联的ISR；</li> <li>通过跳转到<code>ret_from_intr()</code>的地址结束中断处理。</li> </ol> <h2>IRQ(Interrupt ReQuest)线（IRQ向量）的分配</h2> <p>IRQ共享：几个设备共享一个IRQ，中断来时，每个设备的中断服务例程（Interrupt Service Routine，ISR）都执行，检查一下是否与己有关；<br> IRQ动态分配：IRQ可以在使用一个设备的时候才与一个设备关联，这样同一个IRQ就可以被不同的设备在不同时间使用。</p> <p>中断向量中，0-19用于异常和非屏蔽中断，20-31被Intel保留了，32-238这个范围内都可以分配给物理IRQ，但128（0x80）被分配给用于系统调用的可编程异常。</p> <h2>延后的工作谁来做？</h2> <p>首先是两种非紧迫的、可中断的内核函数——可延迟函数（deferrable functions ），然后是通过工作队列（work queues ）来执行的函数。</p> <p>软中断（softirq）是可重入函数而且必须明确地使用自旋锁保护其数据结构；tasklet在软中断基础上实现，但由于内核保证不会在两个CPU上同时运行相同类型的tasklet，所以它不必是可重入的。</p> <h3>六种软中断</h3> <table> <thead> <tr> <th>Softirq</th> <th>Index (priority)</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td>HI_SOFTIRQ</td> <td>0</td> <td>Handles high priority tasklets</td> </tr> <tr> <td>TIMER_SOFTIRQ</td> <td>1</td> <td>Tasklets related to timer interrupts</td> </tr> <tr> <td>NET_TX_SOFTIRQ</td> <td>2</td> <td>Transmits packets to network cards</td> </tr> <tr> <td>NET_RX_SOFTIRQ</td> <td>3</td> <td>Receives packets from network cards</td> </tr> <tr> <td>SCSI_SOFTIRQ</td> <td>4</td> <td>Post-interrupt processing of SCSI commands</td> </tr> <tr> <td>TASKLET_SOFTIRQ</td> <td>5</td> <td>Handles regular tasklets</td> </tr> </tbody> </table> <p>内核会在一些检查点（适宜的时候，其中有时钟中断）检查挂起的软中断，用<code>__do_softirq()</code>执行它们。<code>__do_softirq()</code>会循环若干次，以保证处理掉一些在处理过程中新出现的软中断，但如果还有更多新挂起的软中断，<code>__do_softirq()</code>就不管了，而是调用<code>wakeup_softirq()</code>唤醒每CPU内核进程ksoftirqd/n（这样就可以被调度，而不会一直占着CPU），来处理剩下的软中断。</p> <p>这种做法是为了解决一个矛盾：与网络相关的软中断是高流量的，也是对实时性有一定要求的。但是如果<code>do_softirq()</code>为了实时性一直处理它们，就会一直不返回，结果用户程序就僵在那里了；如果<code>do_softirq()</code>理完一些软中断就返回，不论这中间机器有无空闲，直到下一个时钟中断才又处理其余的，网络处理需要的许多实时性就得不到保证。现在的做法，唤醒内核进程，让它在后台调度，由于内核进程优先级很低，用户程序就有机会运行，不会僵死；但如果机器空闲下来，挂起的软中断很快就能被执行。</p> <p>tasklet则多用于在I/O驱动程序的开发中实现可延迟函数。</p> <p>但是，可延迟函数有一个限制，它是运行在中断上下文的，它执行时不可能有任何正在运行的进程，它也不能调用任何可阻塞（从而会休眠）的函数。这就是工作队列的意义所在。工作队列把需要执行的内核函数交给一些内核进程来执行。</p> <p>处于效率的考虑，内核预定义了叫做events的工作队列，内核开发者可以用schedule_work族函数随意呼唤它们。</p> <h2>内核抢占（Kernel Preemption）</h2> <p>本章在很多地方都涉及到了内核抢占，我觉得还是将内核抢占在本章的笔记记完，不必像原书那样等到内核同步一章了。</p> <p>在非抢占内核的情形，一个执行在内核态的进程是不可能被另外的进程取代的（进程切换）；而在抢占内核的情形，是有可能的：但只有当内核正在执行异常处理程序（尤其是系统调用），而且内核抢占没有被显式禁用的时候，才可能抢占内核。</p> <p>一个例子：当A在处理异常的时候，一个中断的处理程序唤醒了优先级更高的B，在抢占内核的情形，就会发生强制性进程切换。这样做的目的是减少dispatch latency，即从进程（结束阻塞）变为可执行状态到它实际开始运行的时间间隔，降低了它被另外一个运行在内核态的进程延迟的风险。</p> <p>进程描述符中的thread_info字段中有一个32位的preempt_counter字段，0-7位为抢占计数器，用于记录显式禁用内核抢占的次数；8-15位为软中断计数器，记录可延迟函数被禁用的次数；16-27为硬中断计数器，表示中断处理程序的嵌套数（<code>irq_enter()</code>增它，<code>irq_exit()</code>减它）；28位为PREEMPT_ACTIVE标志。只要内核检测到preempt_counter整体不为0，就不会进行内核抢占，这个简单的探测一下子保证了对众多不能抢占的情况的检测。</p> <p>说明：</p> <ol> <li> <p>为了避免在可延迟函数访问的数据结构上发生的竞争条件，最简单直接的方法是禁用中断，但禁用中断有时太夸张了，所以有了禁用可延迟函数这回事。</p> </li> <li> <p>PREEMPT_ACTIVE标志的本意是说明正在抢占，设置了之后preempt_counter就不再为0，从而执行抢占相关工作的代码不会被抢占。</p> </li> </ol> <p>它可被非常tricky地这样使用：</p> <p><code>preempt_schedule()</code>内核抢占时进程调度的入口，其中调用了<code>schedule()</code>它在调用<code>schedule()</code>设置PREEMPT_ACTIVE标志，调用后清除这个标志。而<code>schedule()</code>检查这个标志，对于不是TASK_RUNNING(state != 0)的进程，如果设置了PREEMPT_ACTIVE标志，就不会调用<code>deactivate_task()</code>而<code>deactivate_task()</code>工作是把进程从runqueue移除。</p> <p>你可能会疑惑，为什么要预防已经不在RUNNING状态的进程从runqueue中移除？设想一下，一个进程刚把自己标志为TASK_INTERRUPTIBL，就被preempt了，它还没来得及把自己放进wait_queue中...这个时候当然要让它回头接着运行，直到把自己放进wait_queue然后自愿进程切换，那时才可以把它从runqueue中移除。</p> <p>在面对内核的时候，思维不能僵化在操作系统提供给用户的进程切换的抽象中，而要想象一个永不停歇运行着的、虽然有意识地跳来跳去的指令流的。所以，没有标志为RUNNING不意味就不会还剩下一些（比如处理状态转换的）代码需要执行哦。</p> <p>通过这个标志，保证了被抢占的进程将可以被正确地重新调度和运行。</p> <p>在中断、异常、系统调用返回过程中也会设置PREEMPT_ACTIVE标志。</p> <section class=meta> <p> <span class=author> <a href='/'>宋皿</a> </span> <span class=time> <time datetime='2009-06-19 12:00:00 +0800'> 2009-06-19 </time> </span> </p> <p> <span class=license> Published under <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/' rel=license>(CC) BY-NC-ND</a> </span> <span class=tags> tagged with <a href='/tech/tags.html#tag-内核'> 内核 </a> <a href='/tech/tags.html#tag-linux'> linux </a> <a href='/tech/tags.html#tag-读书笔记'> 读书笔记 </a> </span> </p> </section> <div id=disqus_thread></div> <script>
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'utensil-at-github'; // required: replace example with your forum shortname
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script> <a class=dsq-brlink href='http://disqus.com'> comments powered by <span class=logo-disqus>Disqus</span> </a> </article> </div> </div> </div> <script src="/javascripts/jquery-1.7.1.js?1620110719"></script> <script src="/javascripts/highlight.pack.js?1620110719"></script> <script>
  hljs.initHighlightingOnLoad();
  // $(document).ready(function() {
  //   $('pre code').each(function(i, e) {hljs.highlightBlock(e)});
  // });
</script> <script>
  // (function(e,b){if(!b.__SV){var a,f,i,g;window.mixpanel=b;a=e.createElement("script");a.type="text/javascript";a.async=!0;a.src=("https:"===e.location.protocol?"https:":"http:")+'//cdn.mxpnl.com/libs/mixpanel-2.2.min.js';f=e.getElementsByTagName("script")[0];f.parentNode.insertBefore(a,f);b._i=[];b.init=function(a,e,d){function f(b,h){var a=h.split(".");2==a.length&&(b=b[a[0]],h=a[1]);b[h]=function(){b.push([h].concat(Array.prototype.slice.call(arguments,0)))}}var c=b;"undefined"!== typeof d?c=b[d]=[]:d="mixpanel";c.people=c.people||[];c.toString=function(b){var a="mixpanel";"mixpanel"!==d&&(a+="."+d);b||(a+=" (stub)");return a};c.people.toString=function(){return c.toString(1)+".people (stub)"};i="disable track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config people.set people.set_once people.increment people.append people.track_charge people.clear_charges people.delete_user".split(" ");for(g=0;g<i.length;g++)f(c,i[g]); b._i.push([a,e,d])};b.__SV=1.2}})(document,window.mixpanel||[]); mixpanel.init("eda89891866a7e90b6699df21e79ea61");
  // mixpanel.track("visit");
</script> </body> </html>